import { IInputs, IOutputs } from "./generated/ManifestTypes";

export class indexDB implements ComponentFramework.StandardControl<IInputs, IOutputs> {
    private _notifyOutputChanged: () => void;
    private _container: HTMLDivElement;
    private _db: IDBDatabase | null = null;
    private _dbName: string = "PCFStorage";
    private _storeName: string = "datasets";
    private _lastDBChange: string = "";
    private _storageUsage: number = 0;
    private _colDataOut: string = "";

    constructor() {}

    private async initDB(): Promise<void> {
        if (this._db) {
            return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(this._dbName, 1);

                request.onerror = (event: Event) => {
                    console.error("Database error:", (event.target as IDBRequest).error);
                    this._db = null;
                    reject((event.target as IDBRequest).error);
                };

                request.onsuccess = () => {
                    this._db = request.result;
                    console.log("Database opened successfully");
                    
                    // Add error handler for the database
                    this._db.onerror = (event: Event) => {
                        console.error("Database error:", (event.target as IDBRequest).error);
                        this._db = null;
                    };
                    
                    resolve();
                };

                request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
                    console.log("Database upgrade needed");
                    const db = (event.target as IDBOpenDBRequest).result;
                    
                    // Create the object store if it doesn't exist
                    if (!db.objectStoreNames.contains(this._storeName)) {
                        db.createObjectStore(this._storeName);
                        console.log("Object store created:", this._storeName);
                    }
                };
            } catch (error) {
                console.error("Error initializing database:", error);
                this._db = null;
                reject(error);
            }
        });
    }

    private async updateStorageUsage(): Promise<void> {
        if (!this._db) return;

        const transaction = this._db.transaction(this._storeName, "readonly");
        const store = transaction.objectStore(this._storeName);
        const request = store.getAll();

        return new Promise((resolve) => {
            request.onsuccess = () => {
                const totalSize = request.result.reduce((acc, item) => {
                    return acc + (JSON.stringify(item).length * 2); // Approximate size in bytes
                }, 0);
                this._storageUsage = totalSize / (1024 * 1024); // Convert to MB
                this._notifyOutputChanged();
                resolve();
            };
        });
    }

    private dispatchDBChangeEvent(action: string, colName: string): void {
        this._lastDBChange = JSON.stringify({ action, colName });
        this._notifyOutputChanged();
    }

    public async init(context: ComponentFramework.Context<IInputs>, notifyOutputChanged: () => void, state: ComponentFramework.Dictionary, container: HTMLDivElement): Promise<void> {
        this._notifyOutputChanged = notifyOutputChanged;
        this._container = container;
        await this.initDB();
    }

    public async updateView(context: ComponentFramework.Context<IInputs>): Promise<void> {
        try {
            // Ensure database is initialized
            if (!this._db) {
                await this.initDB();
            }
            
            if (!this._db) {
                throw new Error("Failed to initialize database");
            }

            const colName = context.parameters.colName.raw || "";
            const colData = context.parameters.colData.raw;
            const isWriteAction = context.parameters.writeAction.raw;

            try {
                const transaction = this._db.transaction(this._storeName, "readwrite");
                const store = transaction.objectStore(this._storeName);

                // Add transaction error handling
                transaction.onerror = (event: Event) => {
                    console.error("Transaction error:", (event.target as IDBRequest).error);
                };

                transaction.oncomplete = () => {
                    console.log("Transaction completed successfully");
                };

                // Handle write operations
                if (isWriteAction) {
                    if (colName === "*" && (!colData || colData.trim() === "")) {
                        await new Promise<void>((resolve, reject) => {
                            const request = store.clear();
                            request.onsuccess = () => {
                                this.dispatchDBChangeEvent("deleteAll", colName);
                                resolve();
                            };
                            request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
                        });
                    } else if (!colData || colData.trim() === "") {
                        await new Promise<void>((resolve, reject) => {
                            const request = store.delete(colName);
                            request.onsuccess = () => {
                                this.dispatchDBChangeEvent("delete", colName);
                                resolve();
                            };
                            request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
                        });
                    } else if (colName && colData && colName !== "*") {
                        await new Promise<void>((resolve, reject) => {
                            const request = store.put({ colName, colData });
                            request.onsuccess = () => {
                                this.dispatchDBChangeEvent("update", colName);
                                resolve();
                            };
                            request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
                        });
                    }
                }

                // Handle read operations
                if (!isWriteAction) {
                    if (colName === "*") {
                        const request = store.getAll();
                        request.onsuccess = () => {
                            this._colDataOut = JSON.stringify(request.result);
                            this._notifyOutputChanged();
                        };
                        request.onerror = (event: Event) => {
                            console.error("Error reading all records:", (event.target as IDBRequest).error);
                        };
                    } else {
                        const request = store.get(colName);
                        request.onsuccess = () => {
                            this._colDataOut = request.result ? JSON.stringify(request.result) : "";
                            this._notifyOutputChanged();
                        };
                        request.onerror = (event: Event) => {
                            console.error("Error reading record:", (event.target as IDBRequest).error);
                        };
                    }
                }

                await this.updateStorageUsage();
            } catch (error) {
                console.error("Error in updateView:", error);
            }
        } catch (error) {
            console.error("Error in updateView:", error);
        }
    }

    public getOutputs(): IOutputs {
        return {
            lastDBChange: this._lastDBChange,
            storageUsage: this._storageUsage,
            colDataOut: this._colDataOut
        };
    }

    public destroy(): void {
        if (this._db) {
            this._db.close();
        }
    }
}
