import { IInputs, IOutputs } from "./generated/ManifestTypes";

export class indexDB implements ComponentFramework.StandardControl<IInputs, IOutputs> {
    private _notifyOutputChanged: () => void;
    private _container: HTMLDivElement;
    private _db: IDBDatabase | null = null;
    private _dbName: string = "PCFStorage";
    private _storeName: string = "datasets";
    private _lastDBChange: string = "";
    private _storageUsage: number = 0;
    private _colDataOut: string = "";

    constructor() {}

    private async initDB(): Promise<void> {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this._dbName, 1);

            request.onerror = (event) => {
                console.error("Database error:", request.error);
                reject(request.error);
            };

            request.onsuccess = () => {
                this._db = request.result;
                console.log("Database opened successfully");
                
                // Add error handler for the database
                this._db.onerror = (event) => {
                    console.error("Database error:", (event.target as IDBDatabase).error);
                };
                
                resolve();
            };

            request.onupgradeneeded = (event) => {
                console.log("Database upgrade needed");
                const db = (event.target as IDBOpenDBRequest).result;
                if (!db.objectStoreNames.contains(this._storeName)) {
                    db.createObjectStore(this._storeName, { keyPath: "colName" });
                    console.log("Object store created:", this._storeName);
                }
            };
        });
    }

    private async updateStorageUsage(): Promise<void> {
        if (!this._db) return;

        const transaction = this._db.transaction(this._storeName, "readonly");
        const store = transaction.objectStore(this._storeName);
        const request = store.getAll();

        return new Promise((resolve) => {
            request.onsuccess = () => {
                const totalSize = request.result.reduce((acc, item) => {
                    return acc + (JSON.stringify(item).length * 2); // Approximate size in bytes
                }, 0);
                this._storageUsage = totalSize / (1024 * 1024); // Convert to MB
                this._notifyOutputChanged();
                resolve();
            };
        });
    }

    private dispatchDBChangeEvent(action: string, colName: string): void {
        this._lastDBChange = JSON.stringify({ action, colName });
        this._notifyOutputChanged();
    }

    public async init(context: ComponentFramework.Context<IInputs>, notifyOutputChanged: () => void, state: ComponentFramework.Dictionary, container: HTMLDivElement): Promise<void> {
        this._notifyOutputChanged = notifyOutputChanged;
        this._container = container;
        await this.initDB();
    }

    public async updateView(context: ComponentFramework.Context<IInputs>): Promise<void> {
        if (!this._db) {
            console.error("Database not initialized");
            return;
        }

        const colName = context.parameters.colName.raw || "";
        const colData = context.parameters.colData.raw;
        const isWriteAction = context.parameters.writeAction.raw;

        try {
            const transaction = this._db.transaction(this._storeName, "readwrite");
            const store = transaction.objectStore(this._storeName);

            // Add transaction error handling
            transaction.onerror = (event) => {
                console.error("Transaction error:", transaction.error);
            };

            transaction.oncomplete = () => {
                console.log("Transaction completed successfully");
            };

            // Handle write operations
            if (isWriteAction) {
                if (colName === "*" && (!colData || colData.trim() === "")) {
                    await new Promise<void>((resolve, reject) => {
                        const request = store.clear();
                        request.onsuccess = () => {
                            this.dispatchDBChangeEvent("deleteAll", colName);
                            resolve();
                        };
                        request.onerror = () => reject(request.error);
                    });
                } else if (!colData || colData.trim() === "") {
                    await new Promise<void>((resolve, reject) => {
                        const request = store.delete(colName);
                        request.onsuccess = () => {
                            this.dispatchDBChangeEvent("delete", colName);
                            resolve();
                        };
                        request.onerror = () => reject(request.error);
                    });
                } else if (colName && colData && colName !== "*") {
                    await new Promise<void>((resolve, reject) => {
                        const request = store.put({ colName, colData });
                        request.onsuccess = () => {
                            this.dispatchDBChangeEvent("update", colName);
                            resolve();
                        };
                        request.onerror = () => reject(request.error);
                    });
                }
            }

            // Handle read operations
            if (!isWriteAction) {
                if (colName === "*") {
                    const request = store.getAll();
                    request.onsuccess = () => {
                        this._colDataOut = JSON.stringify(request.result);
                        this._notifyOutputChanged();
                    };
                    request.onerror = () => {
                        console.error("Error reading all records:", request.error);
                    };
                } else {
                    const request = store.get(colName);
                    request.onsuccess = () => {
                        this._colDataOut = request.result ? JSON.stringify(request.result) : "";
                        this._notifyOutputChanged();
                    };
                    request.onerror = () => {
                        console.error("Error reading record:", request.error);
                    };
                }
            }

            await this.updateStorageUsage();
        } catch (error) {
            console.error("Error in updateView:", error);
        }
    }

    public getOutputs(): IOutputs {
        return {
            lastDBChange: this._lastDBChange,
            storageUsage: this._storageUsage,
            colDataOut: this._colDataOut
        };
    }

    public destroy(): void {
        if (this._db) {
            this._db.close();
        }
    }
}
